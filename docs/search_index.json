[["index.html", "Stata Fortbildungen am BIBB Herzlich Willkommen", " Stata Fortbildungen am BIBB Andreas Filser 2021-11-12 Herzlich Willkommen Figure 0.1: Here is a nice figure! Hier entsteht das Begleitskript für die Stata-Weiterbildungen am BIBB von Andreas Filser vom XX bis zum XX.2021. Kapitelübersicht Einstieg Einführung in Stata I Einführung in Stata II Erzeugen von Deskriptions- und Regressionstabellen für Word und LaTex Programmieren mit Postestimates, Macros und Schleifen in Stata "],["stata.html", "1 Überblick zu Stata 1.1 Taschenrechner 1.2 Darstellung in diesem Skript 1.3 DoFile Editor 1.4 Datensätze laden 1.5 Daten, Codebücher, Fragebogen 1.6 Überblicksbefehle 1.7 Übungen 1 1.8 Profi-Übungen 1 1.9 Anhang 1", " 1 Überblick zu Stata Hier sehen wir die Startansicht von Stata: Figure 1.1: Startansicht Stata16 Die Standardansicht von Stata besteht aus mehreren Fenstern: Kommandos/Befehle Ergebnisse Variablenübersicht Übersicht zu den geladenen Daten Befehlshistorie 1.1 Taschenrechner In das Befehlsfeld (1) können wir Kommandos eingeben, z.B. eine Berechnung durchführen. Dazu geben wir zunächst den Befehl display und dann die gewünschte Rechnung ein und drücken dann Enter. Der Befehl wird dann im Ergebnisfenster gespiegelt und darunter das Ergebnis ausgegeben: Wir können display auch mit dis abkürzen. 1.2 Darstellung in diesem Skript Eingaben und Ergebnisse werden im weiteren Skript so dargestellt: display 3 + 12 15 display sqrt(9) 3 1.3 DoFile Editor Zwar funktioniert die direkte Eingabe in das Befehlsfeld, allerdings werden für Auswertungen sehr viel längere und komplexere Befehle und längere Befehlsfolgen verwendet. Für solche Anwendungen werden in Stata sog. DoFiles angelegt. Darin können Befehle entworfen und für eine spätere Verwendung abgespeichert werden. Um ein DoFile zu öffnen geben wir entweder doedit in das Befehlsfeld ein oder klicken auf das Feld New Do-file-Editor rechts oben: Es öffnet sich ein neues Fenster: In diesem sog. Do-File-Editor können wir Befehle entwerfen. Wenn wir diese dann durchführen möchten, markieren wir die entsprechenden Zeilen und drücken STRG + D. Die ausgeführten Befehle werden wieder im Ergebnisfenster gespiegelt und jeweils darunter die Ergebnisse angezeigt: Das DoFile können wir speichern, um es später wieder aufzurufen. Wichtig ist dabei, der gespeicherten Datei die Endung .do zu geben, also zum Beispiel 01_Einstieg.do. Diese DoFiles können dann einfach ausgetauscht werden, um später daran weiter zu arbeiten oder Analysen für Dritte nachvollziehbar zu machen. 1.4 Datensätze laden Das ist aber alles soweit sehr unspektulär - es gibt schönere und günstigere Taschenrechner als Stata. Die eigentliche Stärke von Stata ist die Analyse von Datensätzen. Diese müssen zunächst eingelesen werden. Im einfachsten Fall liegen die Daten als Stata-Datensatz (mit der Endung .dta) vor und wir können die Daten wie folgt einlesen: cd &quot;C:/Kurse/Stata_BIBB/data/&quot; use &quot;BIBBBAuA_2018_suf1.0.dta&quot; Der Einlesevorgang besteht also aus zwei Befehlen: zuerst geben wir cd den Pfad an, unter welchem der einzulesende Datensatz zu finden ist. Natürlich hängt der Dateipfad aber ganz davon ab, wo Sie den Datensatz gespeichert haben, hier ist es C:/Kurse/Stata_BIBB/data/: Um den Pfad des Ordners herauszufinden, klicken Sie bei Windows in die obere Adresszeile im Explorerfenster: In iOS (Mac) finden Sie den Pfad, indem Sie einmal mit der rechten Maustaste auf die Datei klicken und dann die ALT-Taste gedrückt halten. Dann sollte die Option als Pfadname kopieren erscheinen. Youtube Anleitung Hat das funktioniert? Wir haben zwei Möglichkeiten zu das aktuelle Arbeitsverzeichnis überprüfen: wir sehen das aktuelle Arbeitsverzeichnis im Stata-Fenster links unten oder wir geben pwd ein: Wir können diese beiden Schritte natürlich auch einfach kombinieren und den gesamten Pfad nach use angeben: use &quot;C:/Kurse/Stata_BIBB/data/BIBBBAuA_2018_suf1.0.dta&quot; Wenn das funktioniert hat, dann sehen wir im Fenster rechts eine Variablenübersicht: 1.5 Daten, Codebücher, Fragebogen Die Daten des hier geladenen Datensatzes enthalten die Angaben von 20012 Befragten der BIBB/BAuA-Erwerbstätigenbefragung 2018. Die BIBB/BAuA ist eine repräsentativbefragung von in Deutschland zu Arbeit und Beruf im Wandel und Erwerb und Verwertung beruflicher Qualifikation. Das heißt, die hier geladenen Daten beruhen auf standardisierten Interviews. Derartige Datensätze werden in der Regel zusammen mit einem Codebuch, Methodenreport und dem Fragenkatalog veröffentlicht. Im Fragebogen der BIBB/BAuA 2018 finden wir den exakten Wortlaut der Fragen: Hier sind auch die Anweisungen an die Interviewenden vermerkt, z.B. dass die Vorgaben zum Schichtmodell zunächst nicht vorgelesen werden sollen. Außerdem werden im Methodenbericht weitere Variablen vorgestellt, die bereits im Datensatz enthalten sind, beispielsweise das Alter der Befragten, der Wohnort und die berufliche Stellung: Die Antworten der Befragten werden dann im Datensatz gesammelt. Dazu werden den Antworten in der Regel Zahlencodes zugewiesen (siehe die ganz linke Spalte im Fragebogen) und so abgelegt. Stata erlaubt dann in einem zweiten Schritt, dass diese Zahlen wieder mit Wertelabeln versehen werden - dazu kommen wir später. In diesem Datensatz entspricht dann jede Zeile einer befragten Person: In Fragebogendokumentation finden wir Kürzel links oben, welche die Variablennamen für den Datensatz angeben. 1.6 Überblicksbefehle Für eine erste Annäherung an die Daten helfen uns drei Überblicksbefehle: browse, describe und list. Zur Erinnerung: wir haben den Datensatz geladen: cd &quot;C:/Users/Andreas/Dokumente/Statistik/&quot; use &quot;BIBBBAuA_2018_suf1.0.dta&quot; 1.6.1 describe Mit describe, short bekommen wir einen Überblick zu den eingelesenen Daten: describe, short Contains data from D:\\Datenspeicher\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta obs: 20,012 vars: 683 2 Nov 2021 17:34 Sorted by: intnr Hier wurde also ein Datensatz geladen, welcher 20012 Fälle/Zeilen (obs) und 683 Variablen/Spalten (vars) enthält. (Wir können den Befehl auch als d,s abkürzen) Wir können den describe Befehl auch nutzen, um Informationen zu einer Variable zu erhalten. Dazu hängen wir einfach eine oder mehrere Variablen an describe an: describe F209 storage display value variable name type format label variable label -------------------------------------------------------------------------------- F209 byte %8.0g F209 Liegt Ihre Arbeitszeit normalerweise zwischen 7 und 19 Uhr? Hier sehen wir also in der ersten Spalte nochmal den vollständigen Variablennamen, den Variablentypen (storage type - mehr dazu hier) sowie - falls vorhanden - eine Beschreibung der Variable (variable label) sowie (ggf.) die Labels für Ausprägungen der Variable (value label). Letztere können wir mit Hilfe von labelbook aufrufen (mehr zu Labels später): labelbook F209 value label F209 -------------------------------------------------------------------------------- values labels range: [1,9] string length: [2,12] N: 3 unique at full length: yes gaps: yes unique at length 12: yes missing .*: 0 null string: no leading/trailing blanks: no numeric -&gt; numeric: no definition 1 ja 2 nein 9 keine Angabe variables: F209 Wir können auch alle Variablen aufrufen, die mit F209 beginnen, indem wir einen * einsetzen: describe F209* storage display value variable name type format label variable label -------------------------------------------------------------------------------- F209 byte %8.0g F209 Liegt Ihre Arbeitszeit normalerweise zwischen 7 und 19 Uhr? F209_01 byte %8.0g F209_01 Arbeiten Sie in Schichtarbeit? 1.6.2 browse Mit browse bekommen wir eine Ansicht des Datensatzes: browse Wenn wir nur einige Variablen betrachten möchten, hängen wir diese einfach browse an: browse intnr Bula gkpol Stib zpalter Hier bekommen aber immer die gelabelte Ansicht - allerdings stehen dahinter Zahlenwerte. Die Labels helfen uns, deren Bedeutung zu verstehen. Wenn wir aber wie in den nächsten Tagen auch mit den Daten arbeiten wollen, dann beziehen sich diese Operationen immer auf die dahinterstehenden Zahlenwerte. Diese bekommen wir mit der Option nolabel (oft auch einfach als nol abgekürzt): browse intnr Bula gkpol Stib zpalter , nolabel 1.6.3 list browse eignet sich vor allem für größere Übersichten. Wenn wir nur einige wenige Fälle betrachten möchten, dann ist list eine gute Alternative, da der Output hier gleich im Ergebnisfenster (2) angezeigt wird. Die Funktionsweise von list ähnelt sich im Prinzip der von browse. Mit dem Zusatz in 1/5 können wir die ersten 5 Zeilen anzeigen lassen (ansonsten würden alle 20012 Fälle angezeigt!): list intnr Bula gkpol Stib zpalter in 1/5 | intnr Bula gkpol Stib zpalter | |-----------------------------------------------| 1. | 260 Berlin 500.000 Selbstst 41 | 2. | 361 Berlin 500.000 Angestel 51 | 3. | 491 Berlin 500.000 Arbeiter 49 | 4. | 690 Berlin 500.000 Beamter 63 | 5. | 919 Berlin 500.000 Angestel 41 | |-----------------------------------------------| Auch hier können wir wie bei browse die Zahlenwerte ohne die Labels anzeigen lassen, indem wir , nolabel anhängen: list intnr Bula gkpol Stib zpalter in 1/5, nolabel | intnr Bula gkpol Stib zpalter | |---------------------------------------| 1. | 260 11 7 4 41 | 2. | 361 11 7 2 51 | 3. | 491 11 7 1 49 | 4. | 690 11 7 3 63 | 5. | 919 11 7 2 41 | |---------------------------------------| 1.6.4 lookfor All diese Befehle setzen aber voraus, dass wir wissen, unter welchem Variablennamen die interessierende Information abgelegt wurde. Mit lookfor \"stichwort\" können wir den Datensatz nach einem Stichwort durchsuchen: lookfor &quot;schicht&quot; | is not a valid command name r(199); storage display value variable name type format label variable label -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- F209_01 byte %8.0g F209_01 Arbeiten Sie in Schichtarbeit? F210 byte %8.0g F210 In welchen Schichten arbeiten Sie in dieser TÃ¤tigkeit? F211 byte %8.0g F211 Um welche Schichten handelt es sich dabei? F210_01 byte %8.0g F210_01 Belastet Sie das? (Schichtarbeit) Alternativ können wir auch in der Variablenübersicht mit Hilfe des Suchfelds nach Variablen suchen: 1.7 Übungen 1 Öffnen Sie Stata und öffnen Sie den DoFile Editor Führen Sie folgende (oder beliebige andere) Taschenrechneraufgaben mit Stata durch: 2 * 4 2 / 8 2 ^ 2 // (Potenz) sqrt(9) // (Wurzel) Lesen Sie die Erwerbstätigenbefragung 2018 in Stata ein. Folgende Schritte helfen Ihnen dabei: In welchem Arbeitsverzeichnis befindet sich Stata aktuell? Wo können Sie das erkennen? In welchem Ordner haben Sie den Erwerbstätigenbefragung Datensatz abgelegt? Navigieren Sie Stata mit cd in diesen Ordner, in dem der Datensatz abgelegt ist! Nutzen Sie describe und browse, um sich einen Überblick über den Datensatz zu verschaffen. Wie viele Variablen und wie viele Fälle enthält der Datensatz? Unter welchem Variablennamen ist die Information abgelegt, ob der*die Befrage Kinder hat? Nutzen Sie lookfor oder die Suchfunktion im Variablenfenster. Lassen Sie sich die Informationen zur Variable mit describe anzeigen. Wie heißt das angehängte Label? Inspizieren Sie es mit labelbook. Lassen Sie sich diese Variable im Datenexplorer mit browse anzeigen. Lassen Sie sich diese Variable mit den Zahlencodes (nolabel) anstatt der labels anzeigen. 1.8 Profi-Übungen 1 Für alle, die noch etwas mehr machen möchten: Im zip-Ordner finden Sie auch eine SPSS-Version (.sav-Datei) der Erwerbstätigenbefragung 2018. Lesen Sie diese Dateiversion in Stata ein! (Siehe weitere Anmerkungen) 1.9 Anhang 1 1.9.1 Variablentypen In Stata gibt es zwei Variablentypen: Zahlenvariablentypen: byte,int,long,float,double - der Unterschiede zwischen diesen Variablentypen besteht vor allem in der Spannbreite der möglichen Werte: während byte Werte zwischen -127 und 100 annehmen kann, können in long zwischen -2,147,483,647 2,147,483,620 (Stata verwaltet diese Typen in der Regel automatisch - für weitere Hinweise help data_types) Textvariablen, sog. strings strXX - wobei XX die Zahl der (maximal) verwendeten Zeichen angibt In der BIBB/BAuA Erwerbstätigenbefragung 2018 sind nur Zahlenvariablen enthalten. 1.9.2 import anderer Dateiformate Häufig liegen Datensätze nicht im .dta-Format vor, sondern beispielsweise als Excel-Tabelle (.xslx oder .xls), SPSS-Datei (.sav) oder als .csv-Datei. Hierfür stehen alternative Importbefehle zur Verfügung: import excel für Excel Tabellen import spss für SPSS-Dateien import delimited für csv-Dateien Hier empfiehlt sich ein Blick in das Auswahlmenü unter File &gt; Import: Nach Klick auf das entsprechende Dateiformat öffnet sich ein Dialogfenster, in das die gewünschten Optionen eingetragen werden können. Sind alle Optionen wie gewünscht gesetzt, gibt es unten gibt es die Möglichkeit, den so zusammengestellten Befehl nicht nur durchzuführen, sondern auch zu kopieren (um ihn beispielsweise in ein DoFile einzufügen): "],["Stata2.html", "2 Arbeiten mit Datensätzen in Stata 2.1 Befehlsstruktur 2.2 Auszählen &amp; Überblick erhalten 2.3 Fehlende Werte 2.4 Zwei Variablen, eine Tabelle: Kontingenztabellen 2.5 metrische Variablen 2.6 Exkurs: Skalenniveau 2.7 Nochmal von vorne: Daten neu laden 2.8 Speichern 2.9 Übungen 2", " 2 Arbeiten mit Datensätzen in Stata Nachdem wir uns in Stata etwas umgesehen haben, können wir uns jetzt dem eigentlichen Arbeiten mit Datensätzen zuwenden. cd .... use &quot;BIBBBAuA_2018_suf1.0.dta&quot; 2.1 Befehlsstruktur Ganz nebenbei haben wir in Kapitel 1 bereits die ersten Stata-Befehle verwendet. Bevor wir jetzt aber tiefer einsteigen nochmal einmal allgemein: Die grundsätzliche Struktur von Stata-Kommandos ist immer befehl variable, optionen. Zunächst geben wir also immer an, was passieren soll - bisher war das eben zum Beispiel eine Auflistung (list) einiger Variable für einige Zeilen: list intnr Bula gkpol Stib zpalter in 11/12 | intnr Bula gkpol Stib zpalter | |--------------------------------------------------| 11. | 1562 Berlin 500.000 Angestel 31 | 12. | 1955 Berlin 500.000 Angestel 58 | Mit Hilfe von Optionen können wir die Ausgabe verändern: bspw. hatten wir schong gesehen, dass durch das Anhängen der Option nolabel die rohen Zahlenwerte statt der beschrifteten Ausprägungen angezeigt werden: list intnr Bula gkpol Stib zpalter in 11/12, nolabel | intnr Bula gkpol Stib zpalter | |---------------------------------------| 11. | 1562 11 7 2 31 | 12. | 1955 11 7 2 58 | 2.1.1 Zeilenumbrüche Kommandos in Stata sind zeilenbasiert. D.h. alles was zu einem Kommando gehört, muss in der gleichen Zeile stehen. Umgekehrt wird auch alles, was in einer Zeile steht als Teil des Kommandos verstanden. Daher werden bei list intnr Bula gkpol Stib zpalter in 11/15 auch nicht nur intnr sondern auch die anderen Variablen angezeigt. Das funktioniert nicht: list intnr Bula gkpol Stib zpalter in 11/12 (Hier werden erstmal 20012 Zeilen von intnr und Bula ausgegeben) command gkpol is unrecognized r(199); Mit /// können wir Zeilen verknüpfen: list intnr Bula /// gkpol Stib zpalter in 11/12 | intnr Bula gkpol Stib zpalter | |---------------------------------------| 11. | 1562 11 7 2 31 | 12. | 1955 11 7 2 58 | 2.1.2 Kommentare Außerdem können wir mit // Kommentare in unsere DoFiles einfügen. // blendet alles folgende am Ende der Zeile aus: list intnr Bula gkpol Stib zpalter in 11/15 // dies ist ein kommentar /// kann auch zum Kommentieren verwendet werden: list intnr Bula /// hier kann ein kommentar stehen gkpol Stib zpalter in 11/15 // hier geht es weiter, aber der Befehl endet mit dieser Zeile Alternativ können wir mit * eine komplette Zeile deaktivieren: *list intnr Bula gkpol Stib zpalter in 11/15 So wird der Befehl ignoriert. 2.2 Auszählen &amp; Überblick erhalten Mit tabulate bekommen wir eine Auszählung der Ausprägungen einer Variable, indem wir einfach den Variablennamen anhängen (kann auch mit tab m1202 abgekürzt werden): tabulate m1202 | is not a valid command name r(199); HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- keine Angabe | 45 0.22 0.22 Ohne Berufsabschluss | 1,091 5.45 5.68 duale o. schulische Berufsausbildung/ei | 9,297 46.46 52.13 Aufstiegsfortbildung (Meister, Technike | 1,725 8.62 60.75 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.25 100.00 ----------------------------------------+----------------------------------- Total | 20,012 100.00 In der ersten Spalte werden die verschiedenen Ausprägungen aufgelistet, in der zweiten Spalte finden wir dann die absoluten Häufigkeiten (Freq.) der jeweiligen Ausprägung, in der dritten Spalte finden wir die relativen Häufigkeiten (Percent) und in der vierten Spalte (Cum.) finden wir die kumulierten relativen Häufigkeiten: Freq.: der Datensatz enthält 1,091 Befragte ohne Berufsabschluss (absolute Häufigkeit) Percent: 5,45% der im Datensatz enthaltenen Befragte haben keinen Berufsabschluss (relative Häufigkeit) Cum: 5,68% der im Datensatz enthaltenen Befragte haben keinen Berufsabschluss oder machten keine Angabe (kumulierte relative Häufigkeit) Mit nolabel die dahinterliegenden Zahlenwerte anzeigen lassen: tabulate m1202, nolabel | is not a valid command name r(199); HÃ¶chster | Ausbildungs | abschluss | Freq. Percent Cum. ------------+----------------------------------- -1 | 45 0.22 0.22 1 | 1,091 5.45 5.68 2 | 9,297 46.46 52.13 3 | 1,725 8.62 60.75 4 | 7,854 39.25 100.00 ------------+----------------------------------- Total | 20,012 100.00 Mit Hilfe von d und labelbook können wir uns die Labels ausgeben lassen: d m1202 labelbook M1202 | is not a valid command name r(199); storage display value variable name type format label variable label -------------------------------------------------------------------------------- m1202 byte %8.0g M1202 HÃ¶chster Ausbildungsabschluss -------------------------------------------------------------------------------- value label M1202 -------------------------------------------------------------------------------- values labels range: [-1,4] string length: [12,57] N: 5 unique at full length: yes gaps: yes unique at length 12: yes missing .*: 0 null string: no leading/trailing blanks: no numeric -&gt; numeric: no definition -1 keine Angabe 1 Ohne Berufsabschluss 2 duale o. schulische Berufsausbildung/einf.,mittl. Beamte 3 Aufstiegsfortbildung (Meister, Techniker, kfm. AFB u.Ã¤.) 4 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶here Beamte variables: m1202 Für Fälle ohne gültige Angaben zum höchsten Ausbildungsabschluss wurde also -1 als Wert in m1202 abgelegt. Stata berücksichtigt diese Tatsache aber noch nicht und summiert bspw. die kumulierten relativen Häufigkeiten auch über die fehlenden Angaben auf. Um das zu ändern, müssen wir -1 als missing value überschreiben. 2.3 Fehlende Werte Fehlende Werte, sog. missing values werden in Stata mit . abgelegt und werden dann für die weiteren Berechnungen ausgeschlossen. Um also -1 als . zu überschreiben, können wir zB auf den replace Befehl zurückgreifen: tabulate m1202 replace m1202 = . if m1202 == -1 tabulate m1202 | is not a valid command name r(199); HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- keine Angabe | 45 0.22 0.22 Ohne Berufsabschluss | 1,091 5.45 5.68 duale o. schulische Berufsausbildung/ei | 9,297 46.46 52.13 Aufstiegsfortbildung (Meister, Technike | 1,725 8.62 60.75 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.25 100.00 ----------------------------------------+----------------------------------- Total | 20,012 100.00 (45 real changes made, 45 to missing) HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- Ohne Berufsabschluss | 1,091 5.46 5.46 duale o. schulische Berufsausbildung/ei | 9,297 46.56 52.03 Aufstiegsfortbildung (Meister, Technike | 1,725 8.64 60.67 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.33 100.00 ----------------------------------------+----------------------------------- Total | 19,967 100.00 Wir bekommen von Stata mitgeteilt, dass wir 45 Beobachtungen verändert und auf missing gesetzt haben. Im folgenden tabulate werden diese fehlenden Werte dann ignoriert. Ein Spezialbefehl für die Überschreibung von bestimmten Werten ist mvdecode. Mit mvdecode können wir -1 in mehreren Variablen gleichzeitig als missing überschreiben. Zum Beispiel in F100_kldb2010_BOF, F1609_kldb2010_BOF und F1610_kldb2010_BOF: mvdecode F100_kldb2010_BOF F1609_kldb2010_BOF F1610_kldb2010_BOF, mv(-1) | is not a valid command name r(199); F100_k~0_BOF: 64 missing values generated F1609_~0_BOF: 805 missing values generated F1610_~0_BOF: 176 missing values generated (F1609_kldb2010_BOF enthält das BIBB-Berufsoberfeld f. Erwerbsberuf, KldB2010, F1609_kldb2010_BOF die selbe Information für den Vater und F1610_kldb2010_BOF für die Mutter der*des Befragten.) Wir können auch mit / einen Wertebereich angeben, der als Missing definiert werden soll, zB. für das Bundesland der Betriebsstätte: mvdecode F100_wib1, mv(-4/-1) | is not a valid command name r(199); F100_wib1: 104 missing values generated Mit mdesc bekommen wir eine Auszählung zu fehlenden Werten. mdesc ist allerdings kein Standard-Stata-Befehl, sondern muss extra installiert werden. Das ist allerdings kein größerer Aufwand: ssc install mdesc Anschließend können wir mit mdesc die Zahl der missings in zpalter, S2_j, F510 und F511_j ausgeben lassen: mdesc m1202 F100_kldb2010_BOF F1609_kldb2010_BOF F1610_kldb2010_BOF F100_wib1 | is not a valid command name r(199); Variable | Missing Total Percent Missing ----------------+----------------------------------------------- m1202 | 45 20,012 0.22 F100_k~0_BOF | 64 20,012 0.32 F1609_~0_BOF | 4,784 20,012 23.91 F1610_~0_BOF | 17,665 20,012 88.27 F100_wib1 | 104 20,012 0.52 ----------------+----------------------------------------------- Hinweis: welche Angaben als Missing definiert werden sollen, ist teilweise von der Frage ab, die beantwortet werden soll. Bspw. wurden oben alle uneindeutigen Angaben in F233 zum Bundesland der Betriebsstätte als missing codiert. Je nach Fragestellung ist das eine mehr oder weniger gute Idee. In tabulate können wir mit der Option , missing die fehlenden Werte anzeigen lassen: tabulate m1202, missing | is not a valid command name r(199); HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- Ohne Berufsabschluss | 1,091 5.45 5.45 duale o. schulische Berufsausbildung/ei | 9,297 46.46 51.91 Aufstiegsfortbildung (Meister, Technike | 1,725 8.62 60.53 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.25 99.78 . | 45 0.22 100.00 ----------------------------------------+----------------------------------- Total | 20,012 100.00 2.4 Zwei Variablen, eine Tabelle: Kontingenztabellen Neben der einfachen Verteilung der Variable interessiert uns aber meistens, ob sich die Verteilung zwischen Gruppen unterscheidet. Hierfür sind Kontingenztabellen ein wichtiges und sehr häuifg verwendetes Werkzeug. Aus Kontingenztabellen erfahren wir, wie häufig Merkmalskombinationen auftreten. Auch für Kontingenztabellen können wir ebenfalls tabulate verwenden. Zum Beispiel können wir uns eine Tabelle anzeigen lassen, die uns die Ausbildungsabschlüsse getrennt nach Geschlechtern zeigt. Da die Variable S1 keine Missings hat, können wir direkt loslegen. Für die Kontingenztabelle geben wir dann nach tabulate die beiden Variablen an, welche die Zeilen und Spalten definieren: tabulate m1202 S1 | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 594 497 | 1,091 duale o. schulische B | 4,371 4,926 | 9,297 Aufstiegsfortbildung | 1,073 652 | 1,725 Fachhochschule, Unive | 4,015 3,839 | 7,854 ----------------------+----------------------+---------- Total | 10,053 9,914 | 19,967 Wir erkennen aus dieser Tabelle beispielsweise, dass 1,073 Männer und 652 Frauen eine Aufstiegsfortbildung besitzen. 2.4.1 In Prozent: Relative Häufigkeiten Auch hier können wir uns die relativen Häufigkeiten anzeigen lassen, indem wir die Option ,cell anwenden. Um die Tabelle übersichtlich zu halten, können wir mit nofreq die absoluten Häufigkeiten ausblenden (ansonsten werden die absoluten und die relativen Häufigkeiten ausgegeben). tabulate m1202 S1, cell nofreq | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 2.97 2.49 | 5.46 duale o. schulische B | 21.89 24.67 | 46.56 Aufstiegsfortbildung | 5.37 3.27 | 8.64 Fachhochschule, Unive | 20.11 19.23 | 39.33 ----------------------+----------------------+---------- Total | 50.35 49.65 | 100.00 Die hier dargestellten relativen Häufigkeiten beziehen sich jeweils auf die Gesamtzahl der Befragten. Formal dargestellt wird also für die Kombination Aufstiegsfortbildung und Geschlecht = weiblich die Anzahl der Frauen mit Aufstiegsfortbildung durch die Anzahl aller Befragten geteilt: \\(\\frac{\\text{Anzahl der Frauen mit Aufstiegsfortbildung}}{\\text{Gesamtzahl der Befragten}}\\) - Wir können also aus dieser Tabelle ablesen, dass 1,27% aller Befragten weiblich sind und eine Aufstiegsfortbildung haben. Für den Vergleich zwischen Gruppen sind aber in der Regel die bedingten relativen Häufigkeiten informativer. Hier kommt es jetzt darauf an, welche der beiden Variablen die Gruppen definieren sollen und welche Variable wir untersuchen möchten: 2.4.2 pro Gruppe 1: Zeilenprozente Wir können diese Tabelle auch mit Zeilenprozenten anzeigen lassen, indem wir die Option row verwenden: tabulate m1202 S1, row nofreq | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 54.45 45.55 | 100.00 duale o. schulische B | 47.02 52.98 | 100.00 Aufstiegsfortbildung | 62.20 37.80 | 100.00 Fachhochschule, Unive | 51.12 48.88 | 100.00 ----------------------+----------------------+---------- Total | 50.35 49.65 | 100.00 Achtung! Damit ändert sich jeweils die Interpretation der Tabelle! Wir ändern durch row die Bezugsgröße oder formal ausgedrückt den Nenner: Für die Zeilenprozente werden die Werte in Bezug zu den Zeilensummen gesetzt. Also wird die Anzahl der ledigen 35-59 Jährigen ins Verhältnis zur Gesamtzahl der 1x/Woche Internet nutzenden Befragten gesetzt: \\(\\frac{\\text{Anzahl der Frauen mit Aufstiegsfortbildung}}{\\text{Anzahl der Befragten mit Aufstiegsfortbildung}}\\) Interpretation: 37.80% der Befragten mit Aufstiegsfortbildung sind Frauen. 2.4.3 pro Gruppe 2: Spaltenprozente Wir können diese Tabelle auch mit Spaltenprozenten anzeigen lassen, indem wir die Option col verwenden: tabulate m1202 S1, col nofreq | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 5.91 5.01 | 5.46 duale o. schulische B | 43.48 49.69 | 46.56 Aufstiegsfortbildung | 10.67 6.58 | 8.64 Fachhochschule, Unive | 39.94 38.72 | 39.33 ----------------------+----------------------+---------- Total | 100.00 100.00 | 100.00 Für die Spaltenprozente werden die Werte in Bezug zu den Spaltensummen gesetzt. Also wird die Anzahl der 1x/Woche Internet nutzenden Frauen ins Verhältnis zur Zahl der befragten Frauen gesetzt: \\(\\frac{\\text{Anzahl der Frauen mit Aufstiegsfortbildung}}{\\text{Gesamtzahl der befragten Frauen}}\\) - Interpretation: 6.58% der befragten Frauen haben eine Aufstiegsfortbildung. Übung1 2.5 metrische Variablen Für metrisch skalierte Variablen mit deutlich mehr Ausprägungen können wir tabulate zwar theoretisch auch verwenden, allerdings wird eine Tabelle hier sehr schnell sehr unübersichtlich: (Zum Unterschied zwischen metrischen und kategorial skalierten Variablen kommen wir gleich) mvdecode zpalter, mv(9999) tabulate zpalter | is not a valid command name r(199); Alter der | Zielperson | Freq. Percent Cum. -------------+----------------------------------- 15 | 1 0.01 0.01 16 | 3 0.02 0.02 17 | 6 0.03 0.05 18 | 15 0.08 0.13 19 | 36 0.18 0.31 20 | 54 0.27 0.58 21 | 86 0.43 1.01 22 | 117 0.59 1.60 23 | 134 0.68 2.28 24 | 121 0.61 2.89 25 | 129 0.65 3.54 26 | 181 0.91 4.45 27 | 228 1.15 5.60 28 | 243 1.23 6.83 29 | 285 1.44 8.26 30 | 283 1.43 9.69 31 | 337 1.70 11.39 32 | 336 1.69 13.08 33 | 382 1.93 15.01 34 | 384 1.94 16.94 35 | 439 2.21 19.16 36 | 392 1.98 21.13 37 | 406 2.05 23.18 38 | 393 1.98 25.16 39 | 394 1.99 27.15 40 | 394 1.99 29.13 41 | 379 1.91 31.04 42 | 346 1.74 32.79 43 | 419 2.11 34.90 44 | 392 1.98 36.88 45 | 467 2.35 39.23 46 | 497 2.51 41.74 47 | 551 2.78 44.52 48 | 571 2.88 47.39 49 | 689 3.47 50.87 50 | 693 3.49 54.36 51 | 679 3.42 57.78 52 | 724 3.65 61.43 53 | 786 3.96 65.40 54 | 790 3.98 69.38 55 | 743 3.75 73.12 56 | 699 3.52 76.65 57 | 756 3.81 80.46 58 | 648 3.27 83.73 59 | 608 3.07 86.79 60 | 601 3.03 89.82 61 | 528 2.66 92.48 62 | 476 2.40 94.88 63 | 335 1.69 96.57 64 | 225 1.13 97.71 65 | 142 0.72 98.42 66 | 56 0.28 98.70 67 | 49 0.25 98.95 68 | 34 0.17 99.12 69 | 44 0.22 99.34 70 | 29 0.15 99.49 71 | 23 0.12 99.61 72 | 9 0.05 99.65 73 | 11 0.06 99.71 74 | 15 0.08 99.78 75 | 14 0.07 99.85 76 | 7 0.04 99.89 77 | 7 0.04 99.92 78 | 4 0.02 99.94 79 | 2 0.01 99.95 80 | 1 0.01 99.96 81 | 5 0.03 99.98 82 | 1 0.01 99.99 83 | 1 0.01 99.99 87 | 1 0.01 100.00 -------------+----------------------------------- Total | 19,836 100.00 Für metrische Variablen empfiehlt sich daher summarize als Überblicksbefehl: summarize zpalter | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 summarize zpalter kann auch mit su zpalter abgekürzt werden. Hier bekommen wir die Anzahl der Beobachtungen (Obs.), das arithmetische Mittel (Mean), sowie die Minimal- und Maximalwerte ausgegeben (Min&amp;Max). (zur Standardabweichung Std. Dev. kommen wir noch). summarize klappt auch mit mehreren Variablen auf einmal (bei F518_SUF handelt es sich um den monatlichen Bruttoverdienst der Befragten): summarize zpalter F518_SUF // klappt auch mit mehreren Variablen | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 F518_SUF | 16,635 3532.109 3530.928 1 72000 2.6 Exkurs: Skalenniveau Im Zusammenhang mit Alter war gerade von metrischen Variablen die Rede. Dabei geht es um das sog. Skalenniveau von Variablen und Merkmalen. Dabei geht es um den Informationsgehalt von Variablen: welche Informationen können wir aus einer Variable ablesen? Prinzipiell wird zwischen kategorialen und metrischen Skalenniveaus unterschieden. Der zentrale Unterschied besteht darin, dass bei kategorialen Variablen Zahlen_codes_ verwendet werden, wohingegen bei metrischen Variablen die Werte als tatsächliche Zahlenwerte interpretierbar sind. Innerhalb der kategorialen Merkmale wird wiederum zwischen nominaler und ordinaler Skalierung unterschieden, die metrischen Merkmale lassen sich in intervall- und ratio-skalierte Variablen unterscheiden. Sehen wir uns das einmal für die Variablen Geschlecht (S1), Schulbildung (S3), Geburtsjahr (S2_j) und Alter (zpalter) an: list S1 S3 S2_j zpalter in 1/5, nol +--------------------------+ | S1 S3 S2_j zpalter | |--------------------------| 1. | 1 8 1976 41 | 2. | 2 5 1966 51 | 3. | 1 7 1968 49 | 4. | 2 8 1954 63 | 5. | 2 7 1976 41 | +--------------------------+ list S1 S3 S2_j zpalter in 1/5 +--------------------------------------+ | S1 S3 S2_j zpalter | |--------------------------------------| 1. | männlic Abitur / 1976 41 | 2. | weiblich Realschu 1966 51 | 3. | männlic Fachhoch 1968 49 | 4. | weiblich Abitur / 1954 63 | 5. | weiblich Fachhoch 1976 41 | +--------------------------------------+ \\(\\Rightarrow\\) Skalenniveau bestimmt, ob tabulate oder summarize die passenden Befehle sind Literaturtipps: S.18 ff. in Diaz-Bone, R. (2019). Statistik für Soziologen (4. Auflage) S.12 ff. in Bortz, J., &amp; Schuster, C. (2010). Statistik für Human- und Sozialwissenschaftler (7. Auflage) (ausführliche formale Beschreibung) Übung2 2.7 Nochmal von vorne: Daten neu laden Fälle gelöscht, die doch nötig ist? Missings falsch codiert? Das ist zwar ärgerlich, aber ein riesen Vorteil der DoFile-basierten Datenarbeit mit Stata ist die Reproduzierbarkeit. Wir können einfach nochmal von vorne anfangen. Dazu lesen wir die Original-Daten einfach erneut mit use ein. Allerdings ist dann eine Besonderheit zu beachten: use &quot;BIBBBAuA_2018_suf1.0.dta&quot; no; dataset in memory has changed since last saved Wir müssen erst den existierenden Datensatz mit clear löschen clear use &quot;BIBBBAuA_2018_suf1.0.dta&quot; oder die clear Option für use verwenden: use &quot;BIBBBAuA_2018_suf1.0.dta&quot;, clear 2.8 Speichern Natürlich können wir unsere Daten auch abspeichern, wenn alles wie gewünscht geklappt hat. Dafür gibt es den Befehl save, der analog zu use funktioniert. Wenn wir allerdings einfach wieder den Original-Datensatznamen angeben und in der Zwischenzeit Variablen erstellt oder gelöscht haben, dann bekommen wir folgende Fehlermeldung: cd ... save &quot;BIBBBAuA_2018_suf1.0.dta&quot; file BIBBBAuA_2018_suf1.0.dta already exists r(602); Wir geben also entweder einen anderen Dateinamen an: save &quot;BIBBBAuA_2018_suf1.0_NEU.dta&quot; Wir können aber auch mit der Option replace explizit mitteilen, dass die Datei überschrieben werden soll: save &quot;BIBBBAuA_2018_suf1.0.dta&quot;, replace Achtung: Damit sind die Originaldaten aber natürlich weg. 2.9 Übungen 2 2.9.1 Übung 2-1 Laden Sie die Erwerbstätigenbefragung in Stata. Die Variable F100_wib1 erfasst, ob die Befragten in einem wissensintensiven Beruf tätig sind (ja/nein). Lassen Sie sich eine Tabelle für F100_wib2 anzeigen. Welche ist die häufigste Ausprägung? Lassen Sie sich die Zahlencodes anstelle der Labels anzeigen (nolabel) Überschreiben Sie alle Codes für fehlende Angaben mit . (Denken Sie an labelbook). Lassen Sie sich mit tabulate die Häufigkeitsauszählung erneut anzeigen. Hat sich die Fallzahl zu vorhin verändert? Wie können Sie die fehlenden Werte auch in tabulate auszählen lassen? Lassen Sie sich diese Auszählung anzeigen! Für wie viele Befragte liegt keine Angabe zum wissensintensiven Beruf vor? Nutzen Sie mdesc. Lassen Sie sich jetzt F100_wib2 getrennt nach der Wohnortgröße ausgeben. Die Variable gkpol beinhaltet die Größenklasse der Wohngemeinde der Befragten in 7 Kategorien (bis 2000 Einwohner, 2000-5000 Einwohner, usw.) Welche Merkmalskombination ist die häufigste? Welcher Anteil der Befragten aus Städten mit über 500.000 Einwohnern ist in einem wissenintensiven Beruf tätig? Wie hoch ist der Anteil der in einem wissenintensiven Beruf tätig Befragten, die in Orten mit unter 2.000 Einwohnern leben? Kommentieren Sie ihre bisherigen Befehle mit //! Was haben Sie jeweils gemacht? Probieren Sie auch aus, mit /// einen Befehl über mehrere Zeilen zu verteilen! 2.9.2 Übung 2-2 Die Variable F1104 beinhaltet das Jahr des Schulabschlusses. Welches Skalenniveau hat die Variable? Sollten Sie dementsprechend eher tabulate oder summarize verwenden, um einen Überblick zu dieser Variable zu bekommen? Hat die Variable F1104 Werte, die Sie mit . ersetzen sollten? (Denken Sie an labelbook) Führen Sie ggf. die Umcodierung der problematischen Werte auf . durch, um sie so Stata kenntlich zu machen. Lassen Sie sich F1104 erneut mit summarize anzeigen: hat alles geklappt wie es soll? Für wie viele Befragte liegt kein Schulabschlussjahr vor? Nutzen Sie mdesc. "],["desc1.html", "3 Deskriptive Statistik 3.1 Metrische Variablen beschreiben 3.2 Übungen 3 3.3 Anhang Kap 3", " 3 Deskriptive Statistik 3.1 Metrische Variablen beschreiben Im vorherigen Kapitel bezog sich vor allem kategoriale Variablen (mit einer begrenzten Anzahl an Ausprägungen). Für ein metrisches Merkmal, wie zum Beispiel das Alter (zpalter) macht eine Häufigkeitstabelle wenig Sinn, da das Alter sehr viele Ausprägungen hat und eine Tabelle unübersichtlich wäre (es gibt insgesamt 71!). 3.1.1 Exkurs: Klassen bilden Um dieses Problem zu umgehen, könnten wir die Informationen in Klassen/Gruppen zusammenzufassen. So transformieren eine metrische Variable in eine kategoriale, ordinale Variable: Hier nur ein ganz kurzes Beispiel, in Kapitel 4 werden wir uns ausführlicher mit der Erstellung von Variablen in Stata beschäftigen. Für diese Transformation können wir in Stata den egen-Befehl nutzen. Um die Klassen zu bilden, nutzen wir egen zusammen mit der Funktion cut(). In cut geben wir die zu unterteilende Variable an, außerdem legen wir in at() die Grenzen fest. Die so generierten Werte legen wir in einer neuen Variable age_cat ab: egen age_cat = cut(zpalter), at(15 18 35 60 100 ) label | is not a valid command name r(199); (176 missing values generated) Für die neue, klassierte Variable können wir dann wieder mit tabulate eine Häufigkeitstabelle anfordern: tabulate age_cat | is not a valid command name r(199); age_cat | Freq. Percent Cum. ------------+----------------------------------- 15- | 10 0.05 0.05 18- | 3,351 16.89 16.94 35- | 13,855 69.85 86.79 60- | 2,620 13.21 100.00 ------------+----------------------------------- Total | 19,836 100.00 Bspw. erkennen wir in dieser Tabelle, dass 69.85% der Befragten zwischen 35 und 59 Jahre alt sind (Cum. \\(\\Rightarrow\\) 86.79% sind bis zu 59 Jahre alt). Allerdings geht uns dadurch sehr viel Information verloren: wir erkaufen uns die Übersichtlichkeit durch einen Verlust an Präzision bzgl. der Altersangaben. 3.1.2 Lage- und Konzentrationsmaße Allerdings können metrische Variablen auch direkt Hilfe von Lage- und Konzentrationsmaßen beschrieben werden. Klassische Lagemaße zur Beschreibung von metrischen Variablen sind bspw. Minimum und Maximum, das arithm. Mittel sowie der Median und Quantile. Auch hier haben wir bereits den wichtigsten Befehl kennen gelernt: summarize gibt uns einen ersten Überblick zur Verteilung einer metrischen Variable: summarize zpalter | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 Wir erfahren also, dass die Befragten im Mittel 47.19228 Jahre alt sind, die jüngsten Befragten 15 Jahre alt und ältesten Befragten sind 87 Jahre alt. Mit der Option ,detail bekommen wir eine deutlich umfangreichere Auskunft: summarize zpalter, detail | is not a valid command name r(199); Alter der Zielperson ------------------------------------------------------------- Percentiles Smallest 1% 21 15 5% 27 16 10% 31 16 Obs 19,836 25% 38 16 Sum of Wgt. 19,836 50% 49 Mean 47.19228 Largest Std. Dev. 11.33762 75% 56 81 90% 61 82 Variance 128.5417 95% 63 83 Skewness -.3866576 99% 68 87 Kurtosis 2.377842 Hier wird eine ganze Menge auf einmal angezeigt - die Kennzahlen sind dabei in drei Spalten organisiert: Aus der ersten Spalte erfahren wir die Quantile (Percentiles). Ein Quantil einer Verteilung trennt die Daten so in zwei Teile, dass x% der Daten darunter und 100-x% darüber liegen. Hier können wir zB ablesen, dass 25% der Befragten 38 Jahre oder jünger sind. 95% der Befragten sind &lt;= 63 Jahre alt. Dementsprechend sind 5% der Befragten 63 Jahre oder älter. Die 50%-Grenze für das Alter (der Median) liegt bei 49 Jahren.Mehr zu Perzentilen die zweite Spalte gibt uns jeweils die 4 kleinsten und größten Werte für das Alter aus: die 4 kleinsten Alterswerte sind jeweils 15,16,16,16 die größten Werte sind 81,82,83 und 87. in der dritten Spalte bekommen wir eine Reihe weiterer Informationen: die Zahl der Beobachtungen (Obs) und das arithmetische Mittel (Mean) mehr zum arithm. Mittel die Streuung anhand der Standardabweichung (Std. Dev.) und Varianz (Variance) mehr dazu sowie die Schiefe (Skewness) und Wölbung (Kurtosis) mehr dazu 3.1.3 tabstat Häufig möchten wir aber vielleicht nur eine bestimmte Information. Dafür ist tabstat eine gute Lösung. Mit tabstat können wir eine ganze Reihe statistischer Kennzahlen für metrische/kontinuierliche Merkmale berechnen. Die Syntax hat dabei das folgende Format: tabstat zpalter, s(*kennzahl*) Hier eine Übersicht der Kennzahlen: Option Kennzahl Kommentar mean arithm. Mittel Durchschnitt mehr median Median 50% Grenze mehr count Anzahl der Beobachtungen ohne Missings n entspricht count sum Summe der Ausprägungen max Maximum Höchster Wert min Minimum Niedrigster Wert range Spannweite = max - min Wie groß ist der Abstand zwischen kleinstem und größtem Wert? variance Varianz siehe hier sd Standardabweichung siehe hier cv Variationskoefficient (sd/mean) siehe hier skewness Schiefe siehe hier kurtosis Wölbung siehe hier pX X. Perzentil (5,10,25,50,75,90,95,99) zb. p5 \\(\\rightarrow\\) Grenze, unterhalb welcher X% der Beobachtungen liegen iqr Interquartilsdistanz = p75 - p25 Wie groß ist der Abstand zwischen der 25% und 75%-Grenze? q Entspricht p25 p50 p75 Hier ein Bespielbefehl für die Berechnung des arith. Mittels, des Medians, der Varianz und des Varianzkoeffizienten mit tabstat: tabstat zpalter, s(mean median var cv) | is not a valid command name r(199); variable | mean p50 variance cv -------------+---------------------------------------- zpalter | 47.19228 49 128.5417 .2402432 ------------------------------------------------------ Allerdings lassen sich mit tabstat nicht beliebige Quantil-Grenzen (nur für 5,10,25,50,75,90,95,99) berechnen, dafür können wir centile nutzen: centile age, centile(35) | is not a valid command name r(199); -- Binom. Interp. -- Variable | Obs Percentile Centile [95% Conf. Interval] -------------+------------------------------------------------------------- zpalter | 19,836 35 44 43 44 Aus den Angaben unter Centile erfahren wir, dass 35% der Befragten im Datensatz sind 44 Jahre alt oder jünger sind. Dementsprechend sind 65% der Befragten 44 Jahre oder älter. 3.1.4 Kennzahlen vergleichen mit tabstat Interessant sind diese Kennzahlen auch wieder erst im Vergleich zwischen Gruppen. Hierfür steht uns die by()-Option von tabstat zur Verfügung. Bspw. können wir die Altersangaben von Männern und Frauen vergleichen, indem wir in tabstat die Option by(S1) verwenden: tabstat zpalter, s(mean median var cv) by(S1) | is not a valid command name r(199); Summary for variables: zpalter by categories of: S1 (Geschlecht) S1 | mean p50 variance cv ---------+---------------------------------------- mÃ¤nnlich | 46.49079 49 141.0736 .2554795 weiblich | 47.90402 50 114.8336 .2236982 ---------+---------------------------------------- Total | 47.19228 49 128.5417 .2402432 -------------------------------------------------- Wir sehen hier also, dass sowohl das arith. Mittel als auch der Median des Befragtenalters bei Frauen höher ist als bei Männern. Außerdem ist die Streuung bei Männern höher als bei Frauen. Eine andere Option ist es, auf den if-Befehl zurückzugreifen - siehe hier 3.1.5 Streuungsmaße: Varianz, Standardabweichung, Variationskoeffizient Streuungsmaße helfen uns zu beurteilen, wie groß die Unterschiede in unseren Daten sind. Je größer das Streuungsmaß, desto mehr Unterschiede gibt es zwischen den beobachteten Werten. Die häufigste Kennzahl zur Beschreibung von Streuung ist aber die Varianz. Die Varianz ist definiert als die durchschnittliche quadrierte Abweichung vom arith. Mittel: \\[var(x) = \\frac{\\sum_{i=1}^{n} (x_{i}-\\bar{x})^2}{n}\\] Was bedeutet diese Formel? Wir können die Varianz mit tabstat , s(var) berechnen: tabstat zpalter, s(var) | is not a valid command name r(199); variable | variance -------------+---------- zpalter | 128.5417 ------------------------ In unseren Datensatz beträgt der Varianz des Alters also 128,5417 Jahre². Auf der Varianz beruhen noch zwei weitere Streuungsmaße. Die Standardabweichung entspricht der Wurzel der Varianz und hat somit die gleiche Maßeinheit wie die Variable (hier also Jahre): dis sqrt(128.5417) | is not a valid command name r(199); 11.337623 Wir können die Standardabweichung auch mit tabstat , s(sd) berechnen: | is not a valid command name r(199); variable | sd -------------+---------- zpalter | 929.2611 ------------------------ | is not a valid command name r(199); variable | sd -------------+---------- zpalter | 11.33762 ------------------------ Der Variationskoeffizient entspricht sd/mean und dient dem Vergleich verschiedener Streuungen relativ zum jeweiligen Mittelwert, tabstat , s(cv) übernimmt die Berechnung für uns: tabstat zpalter, s(cv) | is not a valid command name r(199); variable | cv -------------+---------- zpalter | .2402432 ------------------------ Somit können wir bspw. mit Hilfe von ,by(S1) die Streuung des Alters bei männlichen und weiblichen Befragten vergleichen: tabstat zpalter, s(cv) by(S1) | is not a valid command name r(199); Summary for variables: zpalter by categories of: S1 (Geschlecht) S1 | cv ---------+---------- mÃ¤nnlich | .2554795 weiblich | .2236982 ---------+---------- Total | .2402432 -------------------- \\(\\Rightarrow\\) Für welches Geschlecht ist die Streuung also größer?1 3.1.6 Gini-Koeffizient Zur Beschreibung der (Ungleich-)Verteilung von metrischen Variablen, insbesondere bei Einkommens- und Vermögensdaten wird häufig der Gini-Koeffizient verwendet. Der Gini-Koeffizient beruht auf der Fläche zwischen der Lorenzkurve und der Gleichverteilung. Auf der x-Achse werden die kumulierten Perzentile der Befragten abgetragen, auf der y-Achse die Perzentile des HH-Einkommens: Den Gini-Koeffizienten können wir mit fastgini berechnen, allerdings müssen wir diesen Befehl erst (einmalig) installieren: ssc install fastgini fastgini F518_SUF | is not a valid command name r(199); Gini coefficient = 0.3543509 Leider funktioniert by(S1) bei fastgini nicht, wir müssen hier auf die Variante mit if zurückgreifen: fastgini F518_SUF if S1 == 1 | is not a valid command name r(199); Gini coefficient = 0.3361488 fastgini F518_SUF if S1 == 2 | is not a valid command name r(199); Gini coefficient = 0.3403522 \\(\\Rightarrow\\) Wo sind die Einkommen also ungleicher verteilt?2 Anmerkung: hier wurden die Missings in F518_SUF mit mvdecode F518_SUF, mv(99998/ 99999) ausgeschlossen. 3.2 Übungen 3 3.2.1 Übung 3-1 Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). Analysieren Sie die Einkommensangaben (F518_SUF): Denken Sie daran, die fehlenden Werte für F518_SUF mit als Missing zu überschreiben! (bspw. mvdecode, sehen Sie mit labelbook F518 Codebuch nach, welche Werte als fehlende Angaben zu betrachten sind) Betrachten Sie die Einkommensangaben mit summarize Für wie viele Beobachtungen haben Sie eine gültige Angabe (nicht-Missing)? Wo liegt das arith. Mittel für die Einkommensangaben? Wie können Sie sich den Median mit Hilfe von summarize ausgeben lassen? Bei welchem Wert liegt die 75%-Perzentilsgrenze? Sind die Einkommensangaben eher rechts- oder linksschief verteilt? Verwenden Sie jetzt tabstat, um folgende Kennzahlen für F518_SUF zu berechnen: Das arithm. Mittel, den Median, das 25%- und 75%-Quartil sowie die Varianz und den Variationskoeffizienten - was sagen Ihnen die Werte jeweils? Berechnen Sie nun alle Werte getrennt für Männer und Frauen (Variable S1) - welche Werte erhalten Sie jeweils für die Kennzahlen? Vergleichen Sie die Werte! Wie unterscheiden sich die Einkommensangaben zwischen Männern und Frauen? Berechnen Sie den Gini-Koeffizenten für F518_SUF! (Denken Sie daran, vor der ersten Verwendung fastgini zu installieren - siehe hier) 3.3 Anhang Kap 3 3.3.1 Arithmetisches Mittel Das arithmetische Mittel wird häufig auch einfach als Durchschnitt bezeichnet: \\[\\bar{x} = \\frac{\\sum_{i=1}^{n}{x_i}}{n}\\] Setzt metrische Daten (also mind. Intervallskalenniveau) voraus: wir interpretieren die Abstände zwischen den Werten. 3.3.2 Median Anordnung aller Werte einer Variable nach Größe Da Rangfolge nötig: mindestens Ordinalskalenniveau Median ist mittlerer Wert dieser geordneten Variable (zentraler Wert) 50% der Werte sind niedriger, 50% der Werte sind höher 3.3.3 Perzentile erklärt Verallgemeinerung des Konzepts des Medians (auch: Quantile) Ein p-Quantil teilt die Daten in zwei Teile, so dass mindestens ein Anteil p der Daten kleiner/ gleich und ein Anteil 1p grösser/ gleich dem p-Quantils-Wert xp ist. Die Ermittlung von p-Quantilen erfolgt analog zur Bestimmung des Medians (der Median entspricht dem 50%-Quantil). Häufig verwendete Quantilsarten: Quartile (25%-, 50%-, 75%-Grenzen), Quintile (20%-, 40%-, 60%-, 80%-Grenzen), Dezile (10%,20%,30%,) Datensatz 1: 1, 2, 3, 4, 5 Mean: 3 Median: 3 20%-Perzentil: 2 Datensatz 2: 1, 2, 3, 4, 10 Mean: 4 Median: 3 20%-Perzentil: 2 3.3.4 Varianz erklärt Die häufigste Kennzahl zur Beschreibung von Streuung ist aber die Varianz. Die Varianz ist definiert als die durchschnittliche quadrierte Abweichung vom arith. Mittel: \\[var(x) = \\frac{\\sum_{i=1}^{n} (x_{i}-\\bar{x})^2}{n}\\] Schauen wir erst in den Zähler des Bruchs: \\((x_{i}-\\bar{x})^2\\) Es geht also um die Abstände der einzelnen Datenpunkte (\\(x_{i}\\)) zum arithmetischen Mittel (\\(\\bar{x}\\)) - mathematisch die Differenz zwischen den einzelnen Datenpunkten \\(x_{i}-\\bar{x}\\) - hier eingezeichnet als gestrichelte Linien: Für Punkte, die über dem arith. Mittel liegen, erhalten wir für die Differenz einen positiven Wert (wir ziehen ja jeweils das arith. Mittel vom Wert für den Datenpunkt ab). Für Punkte mit Werten, die kleiner als das arith. Mittel sind, erhalten wir einen negativen Wert. Würden wir die Abstände (gestrichelten Linien) einfach aufsummieren, erhielten wir als Ergebnis immer Null! Das arithmetische Mittel liegt ja per Definition immer genau in der Mitte: die Abstände nach oben sind in der Summe genauso groß wie die Abstände nach unten. Daher wird zunächst jeder Abstand quadriert: \\((\\bar{x} - x_{i})^2\\) Der Rest der Formel gibt dann an, dass alle quadrierten Differenzen aufsummiert (\\(\\sum_{i=1}^{n}\\)) und dann durch die Anzahl der Beobachtungen geteilt werden (\\(\\frac{}{n}\\))- zusammengefasst hier nochmal die Formel: \\[var(x) = \\frac{\\sum_{i=1}^{n} (x_{i}-\\bar{x})^2}{n}\\] Zurück zu Streuungsmaße 3.3.5 Schiefe &amp; Wölbung Die Schiefe (skewness) ist ein Maß für die Asymmetrie einer Verteilung. Bei einer symmetrischen Verteilung beträgt die Schiefe 0. Ein negativer Wert für die Schiefe deutet darauf hin, dass Median &gt; Mean und Verteilung wird als links-schief/rechts-steil bezeichnet. Bei einem positiven Wert der Schiefe ist Median &lt; Mean und die Verteilung ist rechts-schief/links-steil. Die Wölbung (Kurtosis) ist ein Maß für die Steilheit bzw. Spitzigkeit einer Verteilung. Je kleiner der Wert der Kurtosis, desto desto flacher die Verteilung. Bspw. hat die Normalverteilung hat eine Kurtosis von 3. In Stata bekommen wir die Schiefe und Wölbung einer Verteilung mit summary varname,detail oder mit tabstat varname, s(skewness kurtosis) angezeigt. Mit hist variablenname bekommen wir ein Histogramm ausgegeben, welches einen Überblick wie die oben gezeigten Darstellungen bietet. 3.3.6 Kombination von summarize mit dem by-Präfix Bspw. können wir die Altersangaben für Männer (S1=1) und Frauen (S1=2) vergleichen, indem wir das Befehls-Präfix bys varX: verwenden. bys steht für by sort. Stata sortiert also den Datensatz entsprechend der angegebenen Variable und die folgende Berechnung wird getrennt nach den Werten für varX ausgeführt. Wenn wir also summarize für beide Ausprägungen von S1 berechnen möchten, gehen wir wir folgt vor: bys S1: summarize age | is not a valid command name r(199); -------------------------------------------------------------------------------- -&gt; S1 = mÃ¤nnlic variable age not found r(111); end of do-file r(111); In den neuen Bundesländern sind die Befragten im Schnitt also um 53.90083 - 50.66093 = 3.2399 Jahre älter. 3.3.7 Kennzahlvergleich mit tabulate und der Option summarize() Wir können aber auch zwei Variablen für den Kennzahlenvergleich verwenden. Bspw. sind neben Ost-West-Vergleichen auch häufig Geschlechterunterschiede von Interesse. Stata stellt uns damit mit der summarise-Option eine einfache Möglichkeit zur Verfügung: tab gkpol S1, summarize(zpalter) | is not a valid command name r(199); Means, Standard Deviations and Frequencies of Alter der Zielperson Gemeindeke | nnziffer | Geschlecht politisch | mÃ¤nnlich weiblich | Total -----------+----------------------+---------- unter 2.0 | 47.303435 48.878843 | 48.112349 | 11.895558 10.125739 | 11.045336 | 524 553 | 1077 -----------+----------------------+---------- | 11.528812 10.123345 | 10.853112 | 824 833 | 1657 -----------+----------------------+---------- | 11.767926 10.325446 | 11.099255 | 2492 2460 | 4952 -----------+----------------------+---------- | 11.927508 10.376175 | 11.217466 | 1785 1735 | 3520 -----------+----------------------+---------- | 11.652443 10.927936 | 11.311145 | 828 785 | 1613 -----------+----------------------+---------- | 12.102087 11.040658 | 11.616799 | 1498 1435 | 2933 -----------+----------------------+---------- | 11.910822 11.391779 | 11.673784 | 2039 2045 | 4084 -----------+----------------------+---------- Total | 46.490791 47.904022 | 47.192277 | 11.877443 10.716042 | 11.337623 | 9990 9846 | 19836 Leider funktioniert die Darstellung hier nicht richtig - in Stata werden die Label richtig angezeigt Wir sehen hier, dass 524 Männer aus Wohnorten unter 2000 Einwohnern befragt wurden, die im Durchschnitt 47.30 Jahre alt sind. Die Standardabweichung des Alters in dieser Gruppe beträgt 11.895558 Jahre. Außerdem wurden 785 Frauen aus Wohnorten mit 50.000 bis 99.000 Einwohnern befragt, die im arith. Mittel 48.32 Jahre alt sind und deren Altersangaben eine Standardabweichung 10.9279 aufweisen. Je nach Präferenz können wir eine der drei Kennzahlen (Anzahl der Beobachtungen, arith. Mittel und Standardabw.) ausblenden in dem wir die entsprechende Option verwenden: nofreq Häufigkeiten ausblenden nomeans arith. Mittel ausblenden nostandard Standardabw. ausblenden tab gkpol S1, summarize(age) nofreq würde uns also nur die arith. Mittel und Standardabweichungen ausgeben. Da der Variationskoeffizient für Männer mit 0.2554795 etwas größer ist als für Frauen (0.2236982), ist die Streuung bei den Männern etwas größer. Der etwas höhere Wert des Gini-Koeffizienten legt nahe, dass die Einkommen bei Frauen (S1=2) etwas stärker ungleich verteilt als bei Männern (S1=1). "],["iflab.html", "4 if-Bedingungen 4.1 if-Bedingungen - nur manche Zeilen ansehen 4.2 keep &amp; drop: Fälle dauerhaft löschen 4.3 Übungen 4", " 4 if-Bedingungen 4.1 if-Bedingungen - nur manche Zeilen ansehen Bisher haben wir uns immer auf den gesamten Datensatz bezogen. Häufig möchten wir aber nur bestimmte Beobachtungen berücksichtigen. Ein Beispiel war gerade eben schon der fastgini-Befehl, der keine by-Option hat. Wir können mit einer if-Bedingung mitteilen, dass wir lediglich die Beobachtungen mit S1==2 berücksichtigen möchten (also Frauen): fastgini F518_SUF if S1 == 2 Stata geht dann also alle Zeilen durch und verwendet nur diejenigen mit der entsprechenden Ausprägung. Einige Beispiele list zeigen die Möglichkeiten vielleicht etwas besser: Mit einer if-Bedingung können wir uns die Variablen S1 S3 S2_j und zpalter für 81-jährigen Befragten anzeigen lassen: list S1 S3 S2_j zpalter if zpalter == 81 +--------------------------------------+ | S1 S3 S2_j zpalter | |--------------------------------------| 5114. | männlic Abitur / 1936 81 | 5179. | männlic Abitur / 1936 81 | 6118. | männlic Realschu 1936 81 | 9045. | männlic Abitur / 1936 81 | 10517. | weiblich Hauptsch 1936 81 | +--------------------------------------+ Wichtig ist hier == - ein einfaches = wird in Stata für die Zuweisung von Werten verwendet wie wir noch sehen werden. Für if-Bedingungen stehen uns die üblichen Operatoren zur Verfügung: &gt;, &lt;, ==, &gt;=, &lt;=, != (ungleich) Dementsprechend können wir so Befragte auswählen, die vor 1936 geboren wurden: list S1 S3 S2_j zpalter if S2_j &lt; 1936 Das funktioniert auch mit anderen Befehlen, wie z.B. tabulate - so können wir beispielsweise auszählen, wie viele 81-jährige Frauen und Männer im Datensatz vorhanden sind: tabulate S1 if zpalter == 81 | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 4 80.00 80.00 weiblich | 1 20.00 100.00 ------------+----------------------------------- Total | 5 100.00 Wir sehen unter anderem an der Fallzahl (Total) in dieser Tabelle, dass hier nicht alle Fälle aus dem Datensatz berücksichtigt werden. Wir können auch mehrere Bedingungen setzen. Sollen beide zutreffen, verbinden wir die Bedingungen mit &amp; - zB. wenn wir 81-jährige Befragte mit einem Bruttoverdienst von unter 1000 Euro auswählen möchten: list S1 if zpalter &gt; 81 &amp; F518_SUF &lt; 1000 Mit | können wir hingegen Fälle auswählen, für welche die ein oder die andere Bedingung zutrifft: tabulate S1 if zpalter == 81 | inc &lt; 1000 // 81 Jahre alt oder unter 1000EUR Einkommen Mit inrange können wir Auswahlen auf einen Wertebereich eingrenzen - d.h. diese beiden Auswahlen führen zum gleichen Ergebnis (nur Befragte, die zwischen 20 und 30 Jahre alt sind): tabulate S1 if zpalter &gt;= 20 &amp; zpalter &lt;= 30 tabulate S1 if inrange(zpalter,20,30) Mit inlist können wir spezifische Werte angeben und so lange Folgen von | vermeiden: tabulate S1 if zpalter == 15 | zpalter == 79 | zpalter == 80 | zpalter == 82 tabulate S1 if inlist(zpalter,15,79,80,82) 4.1.1 Labels Genauso könnten wir auch vorgehen wenn wir nur männliche oder weibliche Befragte betrachten möchten. Hier nochmal die Auszählung der Variable S1: tabulate S1 | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,074 50.34 50.34 weiblich | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 Allerdings sind männlich und weiblich lediglich Variablenlabels. D.h. hier wurden Zahlencodes wieder mit Beschreibungen verbunden. Wir können diese Labels nicht für if-Bedingungen verwenden: tab S1 if S1 == &quot;weiblich&quot; type mismatch r(109); Im Hintergrund ist S1 nämlich eine numerische Variable describe S1 | is not a valid command name r(199); storage display value variable name type format label variable label ------------------------------------------------------------------------------------------ S1 byte %8.0g S1 Geschlecht Unter value label sehen wir, dass hier das Label S1 angefügt wurde. Wir können die eigentlichen Werte in tabulate mit der Option ,nol ausblenden: tabulate S1, nol | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- 1 | 10,074 50.34 50.34 2 | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 Wenn wir also nach Frauen filtern möchten, müssen wir den entsprechenden Zahlencode angeben: tab S1 if S1 == 2 | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- weiblich | 9,938 100.00 100.00 ------------+----------------------------------- Total | 9,938 100.00 Mehr zu labels hier 4.1.2 Fehlende Werte Eine häufige Fehlerquelle bei fehlende Werten in Stata ist deren Verhältnis zu &gt;. Fehlende Werte werden nämlich von Stata als unendlich groß gewertet! Wenn wir uns Befragte mit einem Alter über 92 ausgeben lassen, dann bekommen wir auch diejenigen ohne Altersangabe ausgegegeben: list S1 S3 zpalter if zpalter &gt; 81 +-------------------------------+ | S1 S3 zpalter | |-------------------------------| 39. | weiblich Abitur / . | 514. | weiblich Abitur / 83 | 657. | männlic Hauptsch . | 823. | weiblich Realschu . | 982. | weiblich keine An . | |-------------------------------| | 150 weitere Zeilen | Es gibt zwei Möglichkeiten, dies zu umgehen: entweder wir verwenden inrange - wobei wir hier eine Obergrenze angeben müssen und außerdem die Untergrenze immer mit eingeschlossen wird. Wenn wir also nur Fälle sehen wollen, die älter als 81 sind, dann müssen wir einen Wert über 81 angeben: list S1 Bula zpalter if inrange(zpalter,81.5,100) oder wir hängen den missing()-Operator an die Bedingung an. Mit missing(zpalter) können wir alle Zeilen auswählen, für die zpalter missing ist. Wenn wir diesen mit Hilfe eines ! verneinen, können wir die fehlende Fällen ausschließen: list S1 Bula zpalter if zpalter &gt; 81 &amp; !missing(zpalter) Beide Befehle führen zum gleichen Ergebnis: +-------------------------------+ | S1 Bula zpalter | |-------------------------------| 514. | weiblich Hamburg 83 | 6438. | männlic Nordrhei 82 | 11786. | männlic Berlin 87 | +-------------------------------+ 4.2 keep &amp; drop: Fälle dauerhaft löschen Manchmal möchten wir nur bestimmte Beobachtungen im Datensatz behalten. Beispielsweise möchten wir für eine Analyse nur Befragte, die jünger als 30 Jahre sind, im Datensatz behalten. Dazu können wir keep oder drop die gewünschten Fälle behalten bzw. die ungewünschten ausschließen: keep if zpalter &lt; 30 Alternativ können wir auch mit drop alle Befragten aus dem Datensatz löschen, die 60 Jahre oder älter sind: drop if zpalter &gt;= 30 Mit describe, short sehen wir, dass wir jetzt deutlich weniger Fälle im Speicher haben: describe, short | is not a valid command name r(199); Contains data from D:\\Datenspeicher\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta obs: 1,639 vars: 683 2 Nov 2021 17:34 Sorted by: intnr Note: Dataset has changed since last saved. 4.3 Übungen 4 Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). In der Variable intnr ist die Interviewnummer abgelegt. Lassen Sie sich die Interviewnummer (intnr), Alter (zpalter), Geschlecht (S1) und die Wohnortgröße (gkpol) für den*die Befragte mit der Interviewnummer 2388097 ausgeben. Ersetzen Sie die Werte 9999 in zpalter mit .: mvdecode zpalter, mv(9999) Lassen Sie sich eine Häufigkeitsauszählung der Wohnortgröße für folgende Gruppen ausgeben: Befragte, die jünger als 30 Jahre alt sind (das Alter ist in zpalter abgelegt) Befragte, die älter als 60 Jahre alt sind (Denken Sie an den Umgang mit Missings!) Befragte, die jünger als 30 Jahre alt und weiblich sind (das Geschlecht ist in S1 erfasst) Befragte, die jünger als 30 Jahre alt sind oder älter als 60 Jahre alt sind Befragte, die zwischen 30 und 60 Jahre alt sind Lassen Sie sich die Wohngröße (gkpol) für alle Befragte mit fehlender Altersangabe ausgeben. Löschen Sie alle Beobachtungen von Befragten aus Städten mit 500.000 Einwohnern und mehr aus dem Speicher. Denken Sie an die Unterscheidung zwischen Labels und Zahlenwerten. "],["gen.html", "5 Variablen erstellen und verändern 5.1 gen ist gut, Kontrolle ist besser 5.2 Dummy-Variablen erstellen 5.3 Neue Variablen labeln 5.4 Bestehende Variablen verändern 5.5 Übungen 5", " 5 Variablen erstellen und verändern Natürlich sind wir nicht nur darauf beschränkt, bestehende Variablen anzusehen, sondern wir können auch neue Variablen erstellen. Das geht mit gen. Dazu geben wir erst den neuen Variablennamen an und nach =, wie die neue Variable bestimmt werden soll: gen alter_mon = zpalter * 12 su zpalter | is not a valid command name r(199); (176 missing values generated) Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- alter_mon | 19,836 566.3073 136.0515 180 1044 Wenn wir eine Variable überschreiben möchten, dann müssen wir diese erst mit drop löschen, bevor wir sie überschreiben. Würden wir den gen Befehl von gerade nochmal verwenden, dann bekommen wir eine Fehlermeldung: gen alter_mon = zpalter * 12 | is not a valid command name r(199); variable alter_mon already defined r(110); end of do-file r(110); Wir müssen den Namen age_mon also erst wieder frei machen, dann funktioniert der Befehl auch: drop alter_mon gen alter_mon = zpalter * 12 5.1 gen ist gut, Kontrolle ist besser Wie gerade gesehen gibt uns Stata aber keinerlei Erfolgsmeldungen. Nach der Bearbeitung oder Neuurstellung von Variablen sollte ein Blick in die Daten folgen. Dazu empfiehlt es sich, wieder auf den browse Befehl zurückzugreifen: browse intnr zpalter alter_mon In Kombination mit if können wir auch einige Spezialfälle betrachten, z.B. ob die Missings richtig verarbeitet wurden: browse intnr zpalter alter_mon if missing(zpalter) Häufig empfiehlt sich auch ein summarize und ein Vergleich der Missingszahl der alten und neuen Variable mit mdesc: summarize zpalter alter_mon mdesc zpalter alter_mon | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 alter_mon | 19,836 566.3073 136.0515 180 1044 Variable | Missing Total Percent Missing ----------------+----------------------------------------------- zpalter | 176 20,012 0.88 alter_mon | 176 20,012 0.88 ----------------+----------------------------------------------- 5.2 Dummy-Variablen erstellen Wir können auch die Operatoren aus den if-Bedingungen verwenden, um eine Variable zu generieren. Beispielsweise könnten wir eine Dummy-Variable bilden, ob die Befraten im gleichen Bundesland wohnen (Bula) und arbeiten (F233), indem wir den == Operator verwenden. Die entstehende Variable enthält dann immer eine 1 wenn beide Werte gleich sind, unterschiedliche Werte ergeben eine 0: mvdecode Bula F233, mv(97/99) gen ao_wo = Bula == F233 Die Ergebnisse solcher Veränderungen sollten immer überprüft werden! tab ao_wo browse Bula F233 ao_wo list Bula F233 ao_wo in 157/160 | is not a valid command name r(199); +-----------------------------+ | Bula F233 ao_wo | |-----------------------------| | Rheinlan Rheinlan 1 | | Rheinlan Baden-W 0 | | Rheinlan Rheinlan 1 | | Rheinlan . 0 | +-----------------------------+ Allerdings haben wir für F233 doch missings definiert - was passiert mit denen? mdesc Bula F233 ao_wo | is not a valid command name r(199); Variable | Missing Total Percent Missing ----------------+----------------------------------------------- Bula | 0 20,012 0.00 F233 | 285 20,012 1.42 ao_wo | 0 20,012 0.00 ----------------+----------------------------------------------- Leider gleicht Stata auch Missings mit gültigen Werten ab und vergibt dann dementsprechend 0 oder 1. Um die Missings als Missing zu behalten, müssen wir mit entsprechenden if-Bedingungen die Zeilen mit Missings in Bula und F233 ausschließen: drop ao_wo // löschen gen ao_wo = Bula == F233 if !missing(F233) &amp; !missing(Bula) mdesc Bula F233 ao_wo | is not a valid command name r(199); Variable | Missing Total Percent Missing ----------------+----------------------------------------------- Bula | 0 20,012 0.00 F233 | 285 20,012 1.42 ao_wo | 285 20,012 1.42 ----------------+----------------------------------------------- tab ao_wo | is not a valid command name r(199); ao_wo | Freq. Percent Cum. ------------+----------------------------------- 0 | 1,769 8.97 8.97 1 | 17,958 91.03 100.00 ------------+----------------------------------- Total | 19,727 100.00 5.3 Neue Variablen labeln Die so erstellte Dummy-Variable können wir auch labeln. Dazu definieren wir zunächst ein Wertelabel. Dazu verwenden wir label define, gefolgt von einem Objektnamen für dieses Label (hier aowo_lab) und dann jeweils die Ausprägungen zusammen mit dem entsprechenden Label in . Dieses Label-Objekt wenden wir dann mit label values auf die Variable ao_wo an: label define aowo_lab 0 &quot;ungleich&quot; 1 &quot;gleich&quot; label values ao_wo aowo_lab tab ao_wo | is not a valid command name r(199); ao_wo | Freq. Percent Cum. ------------+----------------------------------- ungleich | 1,769 8.97 8.97 gleich | 17,958 91.03 100.00 ------------+----------------------------------- Total | 19,727 100.00 Wenn wir das Label verändern, sehen wir das anschließend auch in tabulate: label define aowo_lab 0 &quot;Ungleich&quot; 1 &quot;Gleich&quot;, replace tab ao_wo | is not a valid command name r(199); ao_wo | Freq. Percent Cum. ------------+----------------------------------- Ungleich | 1,769 8.97 8.97 Gleich | 17,958 91.03 100.00 ------------+----------------------------------- Total | 19,727 100.00 Übung 5-1 5.4 Bestehende Variablen verändern Natürlich können wir auch bestehende Variable verändern, ein Beispiel hatten wir mit mvdecode bereits kennen gelernt. Während es bei mvdecode ja aber nur um Missings geht, gibt es auch Möglichkeiten die gültigen Werte zu verändern. 5.4.1 recode Mit recode können wir Werte in einer bestehenden Variable verändern. Die veränderten Werte können wir in der bestehenden Variable überschreiben. Die häufig bessere Variante ist aber, die Originalwerte zu behalten und die veränderten Werte in einer neuer Variable abzulegen. Das geht mit der Option ,into(neuer_variablenname) Beispielsweise könnten wir gkpol zu weniger Kategorien zusammenfassen - zur Erinnerung, das waren die Originalausprägungen: gkpol neue Variable Wert Label Kategorien 1 unter 2.000 Einwohner 1 - Klein 2 2.000 bis unter 5.000 Einwohner 1 - Klein 3 5.000 bis unter 20.000 Einwohner 1 - Klein 4 20.000 bis unter 50.000 Einwohner 2 - Mittel 5 50.000 bis unter 100.000 Einwohner 2 - Mittel 6 100.000 bis unter 500.000 Einwohner 3 - Groß 7 500.000 und mehr Einwohner 3 - Groß Mit recode können wir diese Ausprägungen zusammenfassen, indem wir immer (alt=neu) angeben. Umcodierungen sollten immer mit tab alt neu überprüft werden: recode gkpol (2=1) (3=1) (4=2) (5=2) (6=3) (7=3), into(gkpol2) tab gkpol gkpol2 | is not a valid command name r(199); (18928 differences between gkpol and gkpol2) | RECODE of gkpol Gemeindekennziffer | (Gemeindekennziffer politisch) politisch | 1 2 3 | Total ----------------------+---------------------------------+---------- unter 2.000 Einwohner | 1,084 0 0 | 1,084 2.000 bis unter 5.000 | 1,670 0 0 | 1,670 5.000 bis unter 20.00 | 5,002 0 0 | 5,002 20.000 bis unter 50.0 | 0 3,550 0 | 3,550 50.000 bis unter 100. | 0 1,624 0 | 1,624 100.000 bis unter 500 | 0 0 2,970 | 2,970 500.000 und mehr Einw | 0 0 4,112 | 4,112 ----------------------+---------------------------------+---------- Total | 7,756 5,174 7,082 | 20,012 Nicht erwähnte Ausprägungen werden einfach übernommen - daher ist 1 hier nicht aufgeführt. Ein Vorteil von recode ist, dass wir direkt Labels vergeben können, die wir einfach in \"\" anhängen - nochmal der gleich Befehl mit direkten Labels: drop gkpol2 // nochmal neu recode gkpol (2=1 &quot;Klein&quot;) (3=1 &quot;Klein&quot;) (4=2 &quot;Mittel&quot;) (5=2 &quot;Mittel&quot;) (6=3 &quot;Groß&quot;) (7=3 &quot;Groß&quot;), into(gkpol2) | is not a valid command name r(199); (18928 differences between gkpol and gkpol2) | RECODE of gkpol Gemeindekennziffer | (Gemeindekennziffer politisch) politisch | Klein Mittel Groß | Total ----------------------+---------------------------------+---------- unter 2.000 Einwohner | 1,084 0 0 | 1,084 2.000 bis unter 5.000 | 1,670 0 0 | 1,670 5.000 bis unter 20.00 | 5,002 0 0 | 5,002 20.000 bis unter 50.0 | 0 3,550 0 | 3,550 50.000 bis unter 100. | 0 1,624 0 | 1,624 100.000 bis unter 500 | 0 0 2,970 | 2,970 500.000 und mehr Einw | 0 0 4,112 | 4,112 ----------------------+---------------------------------+---------- Total | 7,756 5,174 7,082 | 20,012 Tricks, die alle aber zum gleichen Ergebnis führen: Wir können auch mehrere Werte vor dem = angeben: drop gkpol2 recode gkpol (1 2 3=1 &quot;Klein&quot;) (4 5=2 &quot;Mittel&quot;) (6 7=3 &quot;Groß&quot;), into(gkpol2) Außerdem können wir mit Hilfe von / auch Wertebereiche ansprechen: drop gkpol2 recode gkpol (1/3=1 &quot;Klein&quot;) (4/5=2 &quot;Mittel&quot;) (6/7=3 &quot;Groß&quot;), into(gkpol2) Übung 5-2 5.4.2 replace: Informationen aus mehreren Variablen in einer Variable zusammenführen Ein weiterer nützlicher Befehl ist replace. Hier können wir bestehende Variable verändern. Das ist inbesondere in Zusammenspiel mit if-Bedingungen hilfreich. Manchmal liegt eine interessierende Information aufgeteilt auf mehrere Variablen vor. Ein Beispiel hierfür ist die Erwerbskonstellation von Paaren in der Erwerbstätigenbefragung. Wir können aus den Informationen F1600 (Familienstand), F1601 (leben die Befragten mit der*der Partner*in zusammen?) und F1603 (ist Partner*in berufstätig?) eine Variable mit 3 Ausprägungen bauen: 1 nicht verh./alleine lebend 2 verh. &amp; 2 Erwerbspersonen im HH 3 verh. &amp; 1 Erwerbsperson gen erw_hh = . // leere Variable erstellen replace erw_hh = 1 if F1601 == 2 // alleine -&gt; leben nicht zusammen replace erw_hh = 2 if F1601 == 1 &amp; F1603 == 1 // zusammenlebend, Partner*in erwerbstätig replace erw_hh = 3 if F1601 == 1 &amp; F1603 == 2 // zusammenlebend, Partner*in nicht erwerbstätig replace erw_hh = 1 if inlist(F1600,2,3,4) // keine Partnerschaft -&gt; auch auf 1 *! unverheiratete werden hier nicht als Partnerschaften behandelt lab define erw_lab 1 &quot;nicht verh./alleine lebend&quot; 2 &quot;verh. &amp; 2 Erwerbspersonen im HH&quot; 3 &quot;verh. &amp; 1 Erwerbsperson&quot; lab values erw_hh erw_lab tab erw_hh Übung 5-3 5.5 Übungen 5 Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). 5.5.1 Übung 5-1 Erstellen Sie eine Dummy-Variable, die erfasst, ob die Befraten in der gleichen NUTS-2-Region leben und arbeiten nuts2 enthält den Wohnort, F233_nuts2 enthält den Ort der Betriebsstätte Schließen Sie die Missings aus (99996 bis 99999) Erstellen Sie die Variable mit gen. Denken Sie an den == Operator. Kontrollieren Sie das Ergebnis mit browse Definieren Sie Labels für diese Dummyvariable: Wohnort = Arbeitsort Wohnort != Arbeitsort Verändern Sie das Label S1 von 1 = männlich und 2= weiblich auf 1 = Männer und 2 = Frauen. Lassen Sie sich mit tab S1 die Variable ausgeben. Verändern Sie die Labels mit label define .... , replace Lassen Sie sich mit tab S1 die Variable erneut ausgeben - hat das geklappt wie gedacht? 5.5.2 Übung 5-2 Fassen Sie die Variable Gesamtnote Schulabschluss (F1108) in drei Kategorien zusammen: F1108 neue Variable Wert Label neu 1 sehr gut 1 - (sehr) gut 2 gut 1 - (sehr) gut 3 befriedigend 2 - bestanden 4 ausreichend 2 - bestanden 7 keine Note vorgesehen 3 - fehlend 8 weiß nicht 3 - fehlend 9 keine Angabe 3 - fehlend Nutzen Sie die Label-Funktion von recode 5.5.3 Übung 5-3 Fassen Sie die Variablen F209 ( Arbeitszeit normalerweise zwischen 7 und 19 Uhr?) und F223 (mindestens einmal im Monat Sonntagsarbeit) zu einer Variable a_zeit mit folgenden Ausprägungen zusammen: 1 zwischen 7-19 Uhr &amp; keine Sonntagsarbeit 2 nicht zwischen 7-19 Uhr, aber keine Sonntagsarbeit 3 zwischen 7-19 Uhr aber Sonntagsarbeit 4 nicht zwischen 7-19 Uhr und Sonntagsarbeit (Für Tipp weiter nach unten Scrollen) &gt; 1 zwischen 7-19 Uhr &amp; keine Sonntagsarbeit (`F209` == 1, `F223` == 2) &gt; 2 nicht zwischen 7-19 Uhr, aber keine Sonntagsarbeit (`F209` == 2, `F223` == 2) &gt; 3 zwischen 7-19 Uhr aber Sonntagsarbeit (`F209` == 1, `F223` == 1) &gt; 4 nicht zwischen 7-19 Uhr und Sonntagsarbeit (`F209` == 2, `F223` == 1) "],["appendix.html", "6 Anhang - fortgeschrittene Themen 6.1 Index bilden", " 6 Anhang - fortgeschrittene Themen 6.1 Index bilden In Kapitel 5 hatten wir mit recode eine Möglichkeit kennen gelernt, wie Codierungen verändert werden können. Ein typischer Fall ist das Umdrehen von Skalen in einer Item-Batterie, sodass in beiden/allen Variablen höhere Werte auch inhaltlich das gleiche bedeuten. In der BIBB/BAuA 2018 könnten wir bspw. einen Index für die Autonomie/Einbindung am Arbeitsplatz erstellen, indem wir die Antworten aus den folgenden beiden Fragen addieren: + F700_02: Wie häufig kommt es vor, dass Sie Ihre eigene Arbeit selbst planen und einteilen können? + F700_08: Wie oft kommt es vor, dass Sie nicht rechtzeitig über einschneidende Entscheidungen, Veränderungen oder Pläne für die Zukunft informiert werden? Hier wäre es also so, dass der niedrigste Wert (1 = Häufig) jeweils etwas anderes bedeutet. Im Fall von F700_08 Variable betrachten, sehen wir recode F700_02 (4=1) (3=2) (2=3) (1=4), into(F700_02_rev) gen index = (F700_02_rev + F700_10)/2 Inhaltlich ist das sicher nicht 100% überzeugend - hier gehts um die technische Umsetzung Tipp Man kann in diesem speziellen Fall einer umgedrehten Skala können wir auch einfach höchster Wert + 1 minus Variablenwert rechnen. Im Fall von F700_02 ist der höchste Wert 4, also würden wir 4-F700_02 rechnen: gen F700_02_rev2 = 5 - F700_02 "],["test.html", "Test", " Test qui use &quot;D:\\Datenspeicher\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta&quot;, clear list S1 S3 S2_j zpalter in 1/5 , noobs running D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB&gt; rofile.do ... unrecognized command: | invalid command name r(199); +--------------------------------------+ | S1 S3 S2_j zpalter | |--------------------------------------| | mÃ¤nnlic Abitur / 1976 41 | | weiblich Realschu 1966 51 | | mÃ¤nnlic Fachhoch 1968 49 | | weiblich Abitur / 1954 63 | | weiblich Fachhoch 1976 41 | +--------------------------------------+ arithmetisches Mittel: der sog. Durchschnitt Median oder 50%-Perzentil: 50% der Werte sind kleiner &amp; 50% der Werte sind größer 20%-Perzentil: 20% der Werte sind kleiner &amp; 80% der Werte sind größer "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
